/**
 * Offline Queue System
 * 
 * Manages operations that need to be synced when coming back online.
 * Implements optimistic updates with rollback capability.
 */

import { 
  getAll, 
  remove, 
  STORES,
  getDB
} from './indexedDB';

// ============ Types ============

export type OperationType = 
  | 'ADD_DONATION'
  | 'APPROVE_DONATION'
  | 'REJECT_DONATION'
  | 'ADD_PARTICIPANT'
  | 'UPDATE_PARTICIPANT'
  | 'DELETE_PARTICIPANT'
  | 'ADD_ITEM'
  | 'UPDATE_ITEM'
  | 'DELETE_ITEM'
  | 'REORDER_ITEMS';

export type OperationStatus = 'pending' | 'processing' | 'completed' | 'failed';

export interface QueuedOperation {
  id?: number; // Auto-generated by IndexedDB
  type: OperationType;
  eventId: string;
  payload: Record<string, unknown>;
  timestamp: number;
  status: OperationStatus;
  retryCount: number;
  maxRetries: number;
  error?: string;
  // For optimistic updates rollback
  previousState?: Record<string, unknown>;
  // For conflict resolution
  version?: number;
  clientId: string;
}

export interface OfflineQueueState {
  pendingCount: number;
  processingCount: number;
  failedCount: number;
  isProcessing: boolean;
  lastError?: string;
}

// ============ Client ID ============

let clientId: string | null = null;

function getClientId(): string {
  if (clientId) return clientId;
  
  const stored = localStorage.getItem('offlineClientId');
  if (stored) {
    clientId = stored;
    return clientId;
  }
  
  clientId = `client_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
  localStorage.setItem('offlineClientId', clientId);
  return clientId;
}

// ============ Queue Operations ============

/**
 * Add an operation to the offline queue
 */
export async function enqueue(
  type: OperationType,
  eventId: string,
  payload: Record<string, unknown>,
  previousState?: Record<string, unknown>
): Promise<QueuedOperation> {
  const operation: QueuedOperation = {
    type,
    eventId,
    payload,
    timestamp: Date.now(),
    status: 'pending',
    retryCount: 0,
    maxRetries: 3,
    previousState,
    clientId: getClientId()
  };

  const db = await getDB();
  return new Promise((resolve, reject) => {
    const transaction = db.transaction(STORES.OFFLINE_QUEUE, 'readwrite');
    const store = transaction.objectStore(STORES.OFFLINE_QUEUE);
    const request = store.add(operation);

    request.onsuccess = () => {
      operation.id = request.result as number;
      resolve(operation);
    };
    request.onerror = () => reject(request.error);
  });
}

/**
 * Get all pending operations
 */
export async function getPendingOperations(): Promise<QueuedOperation[]> {
  const all = await getAll<QueuedOperation>(STORES.OFFLINE_QUEUE);
  return all
    .filter(op => op.status === 'pending' || op.status === 'failed')
    .sort((a, b) => a.timestamp - b.timestamp);
}

/**
 * Get queue state summary
 */
export async function getQueueState(): Promise<OfflineQueueState> {
  const all = await getAll<QueuedOperation>(STORES.OFFLINE_QUEUE);
  
  return {
    pendingCount: all.filter(op => op.status === 'pending').length,
    processingCount: all.filter(op => op.status === 'processing').length,
    failedCount: all.filter(op => op.status === 'failed').length,
    isProcessing: all.some(op => op.status === 'processing'),
    lastError: all.find(op => op.status === 'failed')?.error
  };
}

/**
 * Update operation status
 */
export async function updateOperationStatus(
  id: number,
  status: OperationStatus,
  error?: string
): Promise<void> {
  const db = await getDB();
  const transaction = db.transaction(STORES.OFFLINE_QUEUE, 'readwrite');
  const store = transaction.objectStore(STORES.OFFLINE_QUEUE);
  
  return new Promise((resolve, reject) => {
    const getRequest = store.get(id);
    
    getRequest.onsuccess = () => {
      const operation = getRequest.result as QueuedOperation;
      if (!operation) {
        resolve();
        return;
      }
      
      operation.status = status;
      if (error) operation.error = error;
      if (status === 'failed') operation.retryCount++;
      
      const putRequest = store.put(operation);
      putRequest.onsuccess = () => resolve();
      putRequest.onerror = () => reject(putRequest.error);
    };
    
    getRequest.onerror = () => reject(getRequest.error);
  });
}

/**
 * Remove completed operation from queue
 */
export async function dequeue(id: number): Promise<void> {
  await remove(STORES.OFFLINE_QUEUE, id);
}

/**
 * Clear all completed operations
 */
export async function clearCompleted(): Promise<void> {
  const all = await getAll<QueuedOperation>(STORES.OFFLINE_QUEUE);
  const completed = all.filter(op => op.status === 'completed');
  
  for (const op of completed) {
    if (op.id) await remove(STORES.OFFLINE_QUEUE, op.id);
  }
}

/**
 * Clear all failed operations
 */
export async function clearFailed(): Promise<void> {
  const all = await getAll<QueuedOperation>(STORES.OFFLINE_QUEUE);
  const failed = all.filter(op => op.status === 'failed' && op.retryCount >= op.maxRetries);
  
  for (const op of failed) {
    if (op.id) await remove(STORES.OFFLINE_QUEUE, op.id);
  }
}

// ============ Operation Helpers ============

/**
 * Create a donation add operation
 */
export function createDonationOperation(
  eventId: string,
  donationData: Record<string, unknown>,
  previousDonations?: unknown[]
): Promise<QueuedOperation> {
  return enqueue('ADD_DONATION', eventId, donationData, { donations: previousDonations });
}

/**
 * Create a participant add operation
 */
export function createParticipantOperation(
  eventId: string,
  participantData: Record<string, unknown>,
  previousParticipants?: unknown[]
): Promise<QueuedOperation> {
  return enqueue('ADD_PARTICIPANT', eventId, participantData, { participants: previousParticipants });
}

/**
 * Create an item add operation
 */
export function createItemOperation(
  eventId: string,
  itemData: Record<string, unknown>,
  previousItems?: unknown[]
): Promise<QueuedOperation> {
  return enqueue('ADD_ITEM', eventId, itemData, { items: previousItems });
}
